# -*- coding: utf-8 -*-
"""Traversing_Graph_Using_DFS_And_BFS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b1ADBNW3eJoxbwYJYVSsiGTtHCKOe9QN
"""

#Undirected graph where each node is connected to their adjacent node on both ways
graph = {"francfurt":["mainhain", "wulzburg", "kassel"],
         "mainhain": ["karlsuhe", "francfurt"],
         "wulzburg": ["francfurt", "numburg", "earthfurt"],
         "kassel":   ["francfurt","munchen"],
         "karlsuhe": ["ausburg","mainhain"],
         "numburg":  ["statgaurd", "wulzburg"],
         "ausburg":["karlsuhe"],
         "statgaurd":["numburg"],
         "earthfurt":["wulzburg"],
         "munchen":["kassel"]
        }

visited_list=[] #creating a list which have been visited means that we have traversed that node

node1=input("enter node: ") #taking input from the user means user will decide from where to start and which will be the parent node

"""DFS(Depth First Search):
In DFS we explore as far as possible along a branch before backtracking.
We start from a parent and visit to its unvisited neighbours until all the neighboers are visited.
When all neighbors are visited then we start backtracking.
"""

def DFS(node1):
  """
  This function is meant to show how the DFS(Depth First Search) algorithm.We are traversing
  all the nodes.Give all the nodes from parent to (top most) lowest node in a branch.

  Parameter:node1 which is the parent node in level 0.
  precondition:key of a dictionary(which is our graph) where particular nodes(keys) are string
  """
  if node1 not in visited_list: #as initially visited_list is empty so the node which will come(recursively) to DFS function will be completely new so this always evaluate to True as long all the nodes are traversed
    print(node1) #printing each node
    visited_list.append(node1) #appending the node to visited list
    for i in graph[node1]: #the node (which is a key of dictionary(graph)) calling the function
      DFS(i) #calling the function recursively

DFS(node1)

"""BFS"""

visited_list=[] #created empty list to add all the nodes level wise

queue_list=[] #created empty list this will keep updating in each level and after adding all the adjacent nodes of a particular node in a level so on going to the next level the previous node is poped out.

"""BFS(Breadth First Search):
In BFS we traverse the graph or tree level by level.
we start from level 0 and visit the adjacent of each node.
It has completeness property(means it will definately give the answer).it is optimal
"""

def BFS(node1):
  """
  This function is meant to show that how the BFS(breath first search algorithm work)
  In this serch we search the goal level by level but here we are traversing all the nodes
  level by level.

  Parameter:node1 is the parent node
  precondition:node1 is the parent node means it is first one to start with which is of type string.

  """
  if node1 not in visited_list: #checking if there is node1 in the visited_list
    visited_list.append(node1) #appending node1 to the visiting list
  for i in graph[node1]: #here loop variable i will be a node(or element of the list because the values of the dictionary(which is our graph)are list so we are accessing each node)
    if i not in visited_list and i not in queue_list: #checking if the i is in the either of the list
      queue_list.append(i) #appending the i to the queue_list
  if queue_list: #this is checking whether the queue_list is empty or not if it is not empty it will evaluate to true
    node1=queue_list.pop(0) #poping out the first element of the queue_list and assigning it to node1 for the trversing all the nodes of node1
    BFS(node1) #calling the function recursively with node1 and it will go on for each node in each level

BFS("kassel") #calling the function
print(queue_list) #printing the queue_list which will be empty at the end
print(visited_list) #printing the visited list